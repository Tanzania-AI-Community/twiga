import logging
import re
import os

from fastapi.responses import JSONResponse

import app.database.models as models
from app.services.flow_service import flow_client
from app.utils.string_manager import strings, StringCategory
from app.services.whatsapp_service import whatsapp_client
import app.database.db as db
from app.services.llm_service import llm_client
import app.database.enums as enums

from fpdf import FPDF
import matplotlib.pyplot as plt
import matplotlib
import re
import tempfile
import os
import fitz  
from PIL import Image as PILImage
import uuid

class MessagingService:
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    async def handle_settings_selection(
        self, user: models.User, message: models.Message
    ) -> JSONResponse:
        self.logger.debug(f"Handling interactive message with title: {message.content}")
        if message.content == "Personal Info":
            self.logger.debug("Sending update personal and school info flow")
            await flow_client.send_user_settings_flow(user)
        elif message.content == "Classes and Subjects":
            self.logger.debug("Sending update class and subject info flow")
            await flow_client.send_subjects_classes_flow(user)
        else:
            raise Exception(f"Unrecognized user reply: {message.content}")
        return JSONResponse(
            content={"status": "ok"},
            status_code=200,
        )

    async def handle_command_message(
        self, user: models.User, message: models.Message
    ) -> JSONResponse:
        self.logger.debug(f"Handling command message: {message.content}")
        assert message.content is not None
        if message.content.lower() == "settings":
            response_text = strings.get_string(StringCategory.SETTINGS, "intro")
            options = [
                strings.get_string(StringCategory.SETTINGS, "personal_info"),
                strings.get_string(StringCategory.SETTINGS, "class_subject_info"),
            ]
            await whatsapp_client.send_message(user.wa_id, response_text, options)
        elif message.content.lower() == "help":
            response_text = strings.get_string(StringCategory.INFO, "help")
            await whatsapp_client.send_message(user.wa_id, response_text)
        else:
            response_text = strings.get_string(
                StringCategory.ERROR, "command_not_found"
            )
            await whatsapp_client.send_message(user.wa_id, response_text)
        return JSONResponse(
            content={"status": "ok"},
            status_code=200,
        )

    async def handle_chat_message(
        self, user: models.User, user_message: models.Message
    ) -> JSONResponse:
        llm_responses = await llm_client.generate_response(
            user=user, message=user_message
        )
        if llm_responses:
            self.logger.debug(
                f"Sending message to {user.wa_id}: {llm_responses[-1].content}"
            )

            # Update the database with the responses
            await db.create_new_messages(llm_responses)

            assert llm_responses[-1].content is not None
            # Send the last message back to the user
            
            final_content = llm_responses[-1].content
            #detect if math:
            math_detected = "<math>" in final_content 

            if math_detected:
                final_content = final_content.replace("$","")  #remove dollar signs if any

                #Make the llm_response into a latex document:
                latex_document_path = text_to_img(final_content)
                
                if latex_document_path:
                    # Send the LaTeX document as an image via WhatsApp
                    await whatsapp_client.send_image_message(
                        wa_id=user.wa_id,
                        image_path=latex_document_path,
                        img_type='image/png',
                        caption="Mathematical Content"
                    )
                
            else:
                #the normal case:
                self.logger.error("CLANKER FOUND NO MATH")

                await whatsapp_client.send_message(user.wa_id, llm_responses[-1].content)

        else:
            self.logger.error("No responses generated by LLM")
            err_message = strings.get_string(StringCategory.ERROR, "general")
            await whatsapp_client.send_message(user.wa_id, err_message)

        return JSONResponse(
            content={"status": "ok"},
            status_code=200,
        )

    async def handle_other_message(
        self, user: models.User, user_message: models.Message
    ) -> JSONResponse:
        assert user.id is not None
        message = models.Message(
            user_id=user.id,
            role=enums.MessageRole.assistant,
            content=strings.get_string(StringCategory.ERROR, "unsupported_message"),
        )
        await db.create_new_message(message)
        # Send message to the user
        await whatsapp_client.send_message(
            user.wa_id, strings.get_string(StringCategory.ERROR, "unsupported_message")
        )
        return JSONResponse(
            content={"status": "ok"},
            status_code=200,
        )


def render_latex_to_image(latex_string, temp_dir):
    """
    Render LaTeX math to an image using matplotlib
    """
    # Configure matplotlib to use LaTeX rendering
    matplotlib.rcParams['text.usetex'] = False  # Use matplotlib's math renderer, not external LaTeX
    matplotlib.rcParams['mathtext.fontset'] = 'cm'  # Use Computer Modern font
    # Create a figure with matplotlib
    fig = plt.figure(figsize=(10, 10), facecolor='white')
    ax = fig.add_subplot(111)
    ax.axis('off')
    
    # Render the LaTeX
    ax.text(0.5, 0.5, f'${latex_string}$', fontsize=100, 
            ha='center', va='center', transform=ax.transAxes,
            color='black')
    
    # Save to temporary file
    img_path = os.path.join(temp_dir, f"math_{abs(hash(latex_string))}.png")
    plt.savefig(img_path, format='png', bbox_inches='tight', 
                dpi=200, facecolor='white', edgecolor='none', pad_inches=0.2)
    plt.close(fig)
    
    return img_path

def text_to_img(content):
    """
    Convert text with LaTeX math to a PNG image. Returns the path to the PNG image.
    """
    # Create PDF
    pdf = FPDF()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.set_font('Helvetica', size=12)
    
    # Create temporary directory for images and PDF
    temp_dir = tempfile.mkdtemp()
    temp_pdf = os.path.join(temp_dir, "temp.pdf")
    
    # Generate unique output filename
    output_path = f"output_{uuid.uuid4().hex[:8]}.png"
    
    try:
        # Parse content: split by <math> tags
        parts = re.split(r'<math>\s*(.*?)\s*(?:</math>|$)', content)
        
        for i, part in enumerate(parts):
            if not part.strip():
                continue
            
            if i % 2 == 0:  # Regular text
                # Add text in a cell
                pdf.cell(0, 10, part.strip(), ln=False)
            else:  # Math content
                try:
                    # Render math as image
                    img_path = render_latex_to_image(part.strip(), temp_dir)
                    
                    # Add line break before image
                    pdf.ln()
                    
                    # Get current position and insert image
                    current_y = pdf.get_y()
                    img_width = 100  # Width in mm
                    
                    # Get image dimensions to calculate actual height
                    with PILImage.open(img_path) as img:
                        img_pixel_width, img_pixel_height = img.size
                    
                    # Calculate height in mm based on width ratio
                    img_height = img_width * (img_pixel_height / img_pixel_width)
                    
                    # Center the image horizontally
                    page_width = pdf.w - pdf.l_margin - pdf.r_margin
                    x_centered = pdf.l_margin + (page_width - img_width) / 2
                    
                    pdf.image(img_path, x=x_centered, y=current_y, w=img_width)
                    
                    # Move cursor below the image using actual height
                    pdf.set_y(current_y + img_height + 2)  # +2mm for spacing
                    
                    # Clean up image
                    os.remove(img_path)

                except Exception as e:
                    # Fallback to plain text
                    pdf.cell(0, 10, f"[{part.strip()}]", ln=True)
                    print(f"Error rendering LaTeX: {e}")
        
        # Save PDF to temp file
        pdf.output(temp_pdf)
        
        # Convert PDF to PNG
        pdf_document = fitz.open(temp_pdf)
        page = pdf_document[0]  # Get first page
        
        # Render page to an image (higher dpi = better quality)
        pix = page.get_pixmap(dpi=300)
        pix.save(output_path)
        
        pdf_document.close()
        print(f"Saved PNG: {output_path}")
        
        return output_path
        
    finally:
        # Clean up temp directory and files
        if os.path.exists(temp_pdf):
            os.remove(temp_pdf)
        if os.path.exists(temp_dir):
            os.rmdir(temp_dir)


messaging_client = MessagingService()
