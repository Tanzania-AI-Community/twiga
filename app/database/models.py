from typing import Any, Dict, List, Optional
from datetime import datetime, timezone, date
from pydantic import BaseModel, ConfigDict
from sqlmodel import (
    Index,
    Field,
    SQLModel,
    UniqueConstraint,
    Column,
    DateTime,
    String,
    ARRAY,
    JSON,
    Relationship,
    Date,
)
from pgvector.sqlalchemy import Vector
import sqlalchemy as sa

import app.database.enums as enums


class ClassInfo(BaseModel):
    """Maps subjects to their grade levels for a teacher"""

    model_config = ConfigDict(arbitrary_types_allowed=True)

    subjects: Dict[str, List[str]]  # keys=Subject, values=List[GradeLevel]

    """ METHODS """

    def model_dump(self, **kwargs):
        data = super().model_dump(**kwargs)
        return {
            subject: [grade for grade in grades]
            for subject, grades in data["subjects"].items()
        }

    def format_readable(self) -> str:
        """
        Formats the class info into a human-readable string.
        Examples:
            "Geography (Form 1, Form 3), Mathematics (Form 5)"
            "Geography (Standard 1), English (Advanced Form 1)"
        """
        if not self.subjects:
            return "No classes assigned"

        formatted_subjects = []
        for subject, grades in self.subjects.items():
            subject_name = enums.SubjectName(subject).display_format
            formatted_grades = sorted(
                [enums.GradeLevel(grade).display_format for grade in grades]
            )
            grades_text = ", ".join(formatted_grades)
            formatted_subjects.append(f"{subject_name} ({grades_text})")

        return ", ".join(formatted_subjects)


class User(SQLModel, table=True):
    __tablename__ = "users"
    model_config = {"arbitrary_types_allowed": True}

    """ FIELDS """
    # The id is optional because it will be generated by the database
    id: Optional[int] = Field(default=None, primary_key=True)
    name: Optional[str] = Field(max_length=50)
    wa_id: str = Field(max_length=20, unique=True, index=True)
    state: enums.UserState = Field(default=enums.UserState.new, max_length=50)
    onboarding_state: Optional[enums.OnboardingState] = Field(
        default=enums.OnboardingState.new, max_length=50
    )
    role: enums.Role = Field(default=enums.Role.teacher, max_length=20)
    class_info: Optional[ClassInfo] = Field(default=None, sa_type=JSON)
    school_name: Optional[str] = Field(default=None, max_length=100)
    birthday: Optional[date] = Field(default=None, sa_type=Date)
    region: Optional[str] = Field(default=None, max_length=50)
    last_message_at: Optional[datetime] = Field(sa_type=DateTime(timezone=True))
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )
    updated_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={
            "onupdate": lambda: datetime.now(timezone.utc),
        },
        nullable=False,
    )

    """ RELATIONSHIPS """
    # A teacher may have entries in the teachers_classes table
    taught_classes: Optional[List["TeacherClass"]] = Relationship(
        back_populates="teacher_", cascade_delete=True  # Could rename to user_
    )

    # A teacher may have entries in the messages table
    user_messages: Optional[List["Message"]] = Relationship(
        back_populates="user_", cascade_delete=True
    )

    """ PROPERTIES """

    @property
    def formatted_class_info(self) -> str:
        """Returns a human-readable string representation of the class info"""
        if not self.class_info:
            return "No classes assigned"

        return ClassInfo(subjects=self.class_info).format_readable()


class Subject(SQLModel, table=True):
    __tablename__ = "subjects"
    model_config = {"arbitrary_types_allowed": True}

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    name: enums.SubjectName = Field(sa_type=String(50), nullable=False)

    """ RELATIONSHIPS """
    # A subject may have entries in the classes table
    subject_classes: Optional[List["Class"]] = Relationship(
        back_populates="subject_", cascade_delete=True
    )


class Class(SQLModel, table=True):
    __tablename__ = "classes"
    __table_args__ = (
        UniqueConstraint("subject_id", "grade_level", name="unique_classes"),
    )
    model_config = {"arbitrary_types_allowed": True}

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    subject_id: int = Field(foreign_key="subjects.id", index=True, ondelete="CASCADE")
    grade_level: enums.GradeLevel = Field(max_length=10, index=True)
    status: enums.SubjectClassStatus = Field(default=enums.SubjectClassStatus.active)

    """ RELATIONSHIPS """
    # A class may have entries in the teachers_classes table
    class_teachers: Optional[List["TeacherClass"]] = Relationship(
        back_populates="class_", cascade_delete=True
    )
    # A class may have entries in the classes_resources table
    class_resources: Optional[List["ClassResource"]] = Relationship(
        back_populates="class_", cascade_delete=True
    )
    # Relationship to the Subject table (since the Subject is a foreign key)
    subject_: Subject = Relationship(back_populates="subject_classes")


class TeacherClass(SQLModel, table=True):
    __tablename__ = "teachers_classes"
    __table_args__ = (
        UniqueConstraint("teacher_id", "class_id", name="unique_teacher_class"),
    )

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    teacher_id: int = Field(foreign_key="users.id", index=True, ondelete="CASCADE")
    class_id: int = Field(foreign_key="classes.id", index=True, ondelete="CASCADE")

    """ RELATIONSHIPS """
    class_: Class = Relationship(back_populates="class_teachers")
    teacher_: User = Relationship(back_populates="taught_classes")


class Message(SQLModel, table=True):
    __tablename__ = "messages"
    model_config = {"arbitrary_types_allowed": True}

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="users.id", index=True, ondelete="CASCADE")
    role: enums.Role = Field(max_length=20)
    content: Optional[str] = Field(default=None)  # None when tool_calls present

    # Tool call related fields
    tool_calls: Optional[List[dict]] = Field(default=None, sa_column=Column(JSON))
    tool_call_id: Optional[str] = Field(default=None)
    tool_name: Optional[str] = Field(default=None, max_length=50)
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
        index=True,
    )

    # Future fields
    # NOTE: add a field for message type (eg. text/image/pdf)
    # NOTE: add a field for the content embedding for when we start doing RAG on chat history

    """ RELATIONSHIPS """
    user_: "User" = Relationship(back_populates="user_messages")

    """ METHODS """

    def to_api_format(self) -> dict:
        """Convert message to OpenAI API format"""
        message = {"role": self.role}
        if self.tool_calls and len(self.tool_calls) > 0:
            message["tool_calls"] = self.tool_calls
            message["content"] = None
        if self.content is not None:
            message["content"] = self.content
        if self.tool_call_id is not None:
            message["tool_call_id"] = self.tool_call_id
        if self.tool_name is not None:
            message["name"] = self.tool_name

        return message

    @classmethod
    def from_api_format(cls, data: dict, user_id: int) -> "Message":
        """Create message from OpenAI API format"""
        tool_calls = data.get("tool_calls")
        if len(data["tool_calls"]) == 0:
            tool_calls = None

        message_data = {
            "user_id": user_id,
            "role": data["role"],
            "content": data.get("content"),
            "tool_calls": tool_calls,
            "tool_call_id": data.get("tool_call_id"),
            "tool_name": data.get("name"),
        }
        return cls(**message_data)


class Resource(SQLModel, table=True):
    __tablename__ = "resources"
    model_config = {"arbitrary_types_allowed": True}

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(max_length=100)
    type: Optional[enums.ResourceType] = Field(max_length=30)
    authors: Optional[List[str]] = Field(sa_column=Column(ARRAY(String(50))))
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )

    """ RELATIONSHIPS """
    resource_classes: Optional[List["ClassResource"]] = Relationship(
        back_populates="resource_", cascade_delete=True
    )
    # resource_sections: Optional[List["Section"]] = Relationship(
    #     back_populates="resource_", cascade_delete=True
    # )
    resource_chunks: Optional[List["Chunk"]] = Relationship(
        back_populates="resource_", cascade_delete=True
    )


class ClassResource(SQLModel, table=True):
    __tablename__ = "classes_resources"

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    class_id: int = Field(foreign_key="classes.id", index=True, ondelete="CASCADE")
    resource_id: int = Field(foreign_key="resources.id", index=True, ondelete="CASCADE")

    """ RELATIONSHIPS """
    class_: Class = Relationship(back_populates="class_resources")
    resource_: Resource = Relationship(back_populates="resource_classes")


class Chunk(SQLModel, table=True):
    __tablename__ = "chunks"
    __table_args__ = (
        Index(
            "chunk_embedding_idx",  # index name
            "embedding",  # column name
            postgresql_using="hnsw",
            postgresql_with={"m": 16, "ef_construction": 64},
            postgresql_ops={"embedding": "vector_cosine_ops"},
        ),
    )
    model_config = {"arbitrary_types_allowed": True}

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    resource_id: int = Field(foreign_key="resources.id", index=True, ondelete="CASCADE")
    # section_id: Optional[int] = Field(
    #     foreign_key="sections.id", index=True, ondelete="CASCADE", default=None
    # )
    content: str
    page_number: Optional[int] = Field(default=None)
    # TODO: Define the different types of chunks in an enum
    chunk_type: Optional[enums.ChunkType] = Field(max_length=30, default=None)
    """
    XXX: FILL IN THE EMBEDDING LENGTH FOR YOUR EMBEDDINGS
    - Default is set to 1024 (for bge-large vectors)
    - Replace with 1536 for text-embedding-3-small if using OpenAI's embedder
    """
    embedding: Any = Field(sa_column=Column(Vector(1024)))
    top_level_section_index: Optional[str] = Field(max_length=10, default=None)
    top_level_section_title: Optional[str] = Field(max_length=100, default=None)
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )

    """ RELATIONSHIPS """
    resource_: Optional["Resource"] = Relationship(back_populates="resource_chunks")
    # section_: Optional["Section"] = Relationship(back_populates="section_chunks")


# class Section(SQLModel, table=True):
#     __tablename__ = "sections"

#     """ FIELDS """
#     id: Optional[int] = Field(default=None, primary_key=True)
#     resource_id: int = Field(foreign_key="resources.id", index=True, ondelete="CASCADE")
#     parent_section_id: Optional[int] = Field(
#         default=None, foreign_key="sections.id", nullable=True
#     )
#     section_index: Optional[str] = Field(max_length=20, default=None)
#     section_title: Optional[str] = Field(max_length=100, default=None)
#     section_type: Optional[str] = Field(max_length=15, default=None)
#     section_order: int
#     page_range: Optional[List[int]] = Field(sa_column=Column(ARRAY(Integer)))
#     summary: Optional[str] = Field(default=None)
#     created_at: Optional[datetime] = Field(
#         default_factory=lambda: datetime.now(timezone.utc),
#         sa_type=DateTime(timezone=True),  # type: ignore
#         sa_column_kwargs={"server_default": sa.func.now()},
#         nullable=False,
#     )

#     """ RELATIONSHIPS """
#     resource_: Resource = Relationship(back_populates="resource_sections")
#     parent: Optional["Section"] = Relationship(
#         back_populates="children",
#         sa_relationship_kwargs={
#             "remote_side": "[Section.id]"  # Quote wrapped to handle forward references
#         },
#     )

#     # Only part I'm not too sure about
#     children: Optional[List["Section"]] = Relationship(
#         back_populates="parent",
#         cascade_delete=True,
#         sa_relationship_kwargs={
#             "single_parent": True,  # This ensures a child can only have one parent
#         },
#     )
#     section_chunks: Optional[List["Chunk"]] = Relationship(
#         back_populates="section_", cascade_delete=True
#     )
