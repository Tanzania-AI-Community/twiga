from typing import Any, Dict, List, Optional, TYPE_CHECKING
from datetime import datetime, timezone, date
from pydantic import BaseModel, ConfigDict
from sqlmodel import (
    Index,
    Field,
    SQLModel,
    UniqueConstraint,
    Column,
    DateTime,
    String,
    ARRAY,
    JSON,
    Relationship,
    Date,
)
from pgvector.sqlalchemy import Vector
import sqlalchemy as sa

if TYPE_CHECKING:
    from langchain_core.messages import BaseMessage

import app.database.enums as enums


class ClassInfo(BaseModel):
    """Maps subjects to their grade levels for a teacher"""

    model_config = ConfigDict(arbitrary_types_allowed=True)

    classes: Dict[str, List[str]]  # keys=Subject, values=List[GradeLevel]

    """ METHODS """

    def model_dump(self, **kwargs):
        data = super().model_dump(**kwargs)
        return {
            subject: [grade for grade in grades]
            for subject, grades in data["classes"].items()
        }

    def format_readable(self) -> str:
        """
        Formats the class info into a human-readable string.
        Examples:
            "Geography (Form 1, Form 3), Mathematics (Form 5)"
            "Geography (Standard 1), English (Advanced Form 1)"
        """
        if not self.classes:
            return "No classes assigned"

        formatted_classes = []
        for subject, grades in self.classes.items():
            subject_name = enums.SubjectName(subject).display_format
            formatted_grades = sorted(
                [enums.GradeLevel(grade).display_format for grade in grades]
            )
            grades_text = ", ".join(formatted_grades)
            formatted_classes.append(f"{subject_name} ({grades_text})")

        return ", ".join(formatted_classes)


class User(SQLModel, table=True):
    __tablename__ = "users"  # type: ignore
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    # The id is optional because it will be generated by the database
    id: Optional[int] = Field(default=None, primary_key=True)
    name: Optional[str] = Field(max_length=50)
    wa_id: str = Field(max_length=20, unique=True, index=True)
    state: enums.UserState = Field(default=enums.UserState.in_review, max_length=50)
    onboarding_state: Optional[enums.OnboardingState] = Field(
        default=enums.OnboardingState.new, max_length=50
    )
    role: enums.Role = Field(default=enums.Role.teacher, max_length=20)
    class_info: Optional[Dict[str, List[str]]] = Field(default=None, sa_type=JSON)
    school_name: Optional[str] = Field(default=None, max_length=100)
    birthday: Optional[date] = Field(default=None, sa_type=Date)
    region: Optional[str] = Field(default=None, max_length=50)
    last_message_at: Optional[datetime] = Field(default=None, sa_type=sa.DateTime(timezone=True))  # type: ignore
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )
    updated_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={
            "onupdate": lambda: datetime.now(timezone.utc),
        },
        nullable=False,
    )

    """ RELATIONSHIPS """
    # A teacher may have entries in the teachers_classes table
    taught_classes: Optional[List["TeacherClass"]] = Relationship(
        back_populates="teacher_", cascade_delete=True  # Could rename to user_
    )

    # A teacher may have entries in the messages table
    user_messages: Optional[List["Message"]] = Relationship(
        back_populates="user_", cascade_delete=True
    )

    """ PROPERTIES """

    @property
    def formatted_class_info(self) -> str:
        """Returns a human-readable string representation of the class info"""
        if not self.class_info:
            return "No classes assigned"

        return ClassInfo(classes=self.class_info).format_readable()

    @property
    def class_name_to_id_map(self) -> Dict[str, int]:
        """
        Returns a mapping of class names (with subject and form) to their IDs.
        Example: {"Geography Form 2": 123, "Geography Form 3": 456}
        """

        if not self.taught_classes:
            return {}

        # TODO: This can be done in a better way without suppressing the type
        return {
            f"{class_.class_.subject_.name.capitalize()} {enums.GradeLevel(class_.class_.grade_level).display_format}": class_.class_.id
            for class_ in self.taught_classes
        }  # type: ignore


class Subject(SQLModel, table=True):
    __tablename__ = "subjects"  # type: ignore
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    name: enums.SubjectName = Field(max_length=50, nullable=False)

    """ RELATIONSHIPS """
    # A subject may have entries in the classes table
    subject_classes: Optional[List["Class"]] = Relationship(
        back_populates="subject_", cascade_delete=True
    )


class Class(SQLModel, table=True):
    __tablename__ = "classes"  # type: ignore
    __table_args__ = (
        UniqueConstraint("subject_id", "grade_level", name="unique_classes"),
    )
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    subject_id: int = Field(foreign_key="subjects.id", index=True, ondelete="CASCADE")
    grade_level: enums.GradeLevel = Field(max_length=10, index=True)
    status: enums.SubjectClassStatus = Field(default=enums.SubjectClassStatus.active)

    """ RELATIONSHIPS """
    # A class may have entries in the teachers_classes table
    class_teachers: Optional[List["TeacherClass"]] = Relationship(
        back_populates="class_", cascade_delete=True
    )
    # A class may have entries in the classes_resources table
    class_resources: Optional[List["ClassResource"]] = Relationship(
        back_populates="class_", cascade_delete=True
    )
    # Relationship to the Subject table (since the Subject is a foreign key)
    subject_: Subject = Relationship(back_populates="subject_classes")


class TeacherClass(SQLModel, table=True):
    __tablename__ = "teachers_classes"  # type: ignore
    __table_args__ = (
        UniqueConstraint("teacher_id", "class_id", name="unique_teacher_class"),
    )

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    teacher_id: int = Field(foreign_key="users.id", index=True, ondelete="CASCADE")
    class_id: int = Field(foreign_key="classes.id", index=True, ondelete="CASCADE")

    """ RELATIONSHIPS """
    class_: Class = Relationship(back_populates="class_teachers")
    teacher_: User = Relationship(back_populates="taught_classes")


class Message(SQLModel, table=True):
    __tablename__ = "messages"  # type: ignore
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="users.id", index=True, ondelete="CASCADE")
    role: enums.MessageRole = Field(max_length=20)
    content: Optional[str] = Field(default=None)  # None when tool_calls present
    media_id: Optional[str] = Field(default=None)   
    mime_type: Optional[str] = Field(default=None)

    # Tool call related fields
    tool_calls: Optional[List[dict]] = Field(default=None, sa_column=Column(JSON))
    tool_call_id: Optional[str] = Field(default=None)
    tool_name: Optional[str] = Field(default=None, max_length=50)
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
        index=True,
    )

    # Future fields
    # NOTE: add a field for message type (eg. text/image/pdf)
    # NOTE: add a field for the content embedding for when we start doing RAG on chat history

    """ RELATIONSHIPS """
    user_: "User" = Relationship(back_populates="user_messages")

    """ METHODS """

    def to_api_format(self) -> Dict[str, Any]:
        """Convert message to OpenAI API format (kept for backward compatibility)"""
        message: Dict[str, Any] = {"role": self.role.value}
        if self.tool_calls and len(self.tool_calls) > 0:
            message["tool_calls"] = self.tool_calls
            message["content"] = None
        if self.content is not None:
            message["content"] = self.content
        if self.tool_call_id is not None:
            message["tool_call_id"] = self.tool_call_id
        if self.tool_name is not None:
            message["name"] = self.tool_name
        if self.media_id is not None:
            message["media_id"] = self.media_id
        if self.mime_type is not None:
            message["mime_type"] = self.mime_type

        return message

    def to_langchain_message(self) -> "BaseMessage":
        """Convert message to LangChain BaseMessage format"""
        from langchain_core.messages import (
            SystemMessage,
            HumanMessage,
            AIMessage,
            ToolMessage,
        )

        content = self.content or ""

        if self.role == enums.MessageRole.system:
            return SystemMessage(content=content)
        elif self.role == enums.MessageRole.user:
            return HumanMessage(content=content)
        elif self.role == enums.MessageRole.assistant:
            if self.tool_calls:
                return AIMessage(
                    content=content, additional_kwargs={"tool_calls": self.tool_calls}
                )
            else:
                return AIMessage(content=content)
        elif self.role == enums.MessageRole.tool:
            return ToolMessage(content=content, tool_call_id=self.tool_call_id or "")
        else:
            # Raise an error for unknown roles
            raise ValueError(
                f"Unknown message role: {self.role}. Expected one of: {[role.value for role in enums.MessageRole]}"
            )

    @classmethod
    def from_api_format(cls, data: dict, user_id: int) -> "Message":
        """Create message from OpenAI API format"""

        tool_calls = data.get("tool_calls")
        if data["tool_calls"] is None or len(data["tool_calls"]) == 0:
            tool_calls = None

        message_data = {
            "user_id": user_id,
            "role": data["role"],
            "content": data.get("content"),
            "tool_calls": tool_calls,
            "tool_call_id": data.get("tool_call_id"),
            "tool_name": data.get("name"),
        }
        return cls(**message_data)

    @classmethod
    def from_langchain_message(cls, message: "BaseMessage", user_id: int) -> "Message":
        """Create message from LangChain BaseMessage format"""
        from langchain_core.messages import (
            SystemMessage,
            HumanMessage,
            AIMessage,
            ToolMessage,
        )

        # Determine role based on message type
        if isinstance(message, SystemMessage):
            role = enums.MessageRole.system
        elif isinstance(message, HumanMessage):
            role = enums.MessageRole.user
        elif isinstance(message, AIMessage):
            role = enums.MessageRole.assistant
        elif isinstance(message, ToolMessage):
            role = enums.MessageRole.tool
        else:
            role = enums.MessageRole.system  # Fallback

        # Extract content
        content = message.content if message.content else None

        # Extract tool calls for AIMessage
        tool_calls = None
        if (
            isinstance(message, AIMessage)
            and hasattr(message, "tool_calls")
            and message.tool_calls
        ):
            tool_calls = [
                (
                    tool_call.model_dump()
                    if isinstance(tool_call, BaseModel)
                    else tool_call
                )
                for tool_call in message.tool_calls
            ]
        elif isinstance(message, AIMessage) and hasattr(message, "additional_kwargs"):
            tool_calls = message.additional_kwargs.get("tool_calls")

        # Extract tool call ID for ToolMessage
        tool_call_id = None
        if isinstance(message, ToolMessage):
            tool_call_id = message.tool_call_id

        message_data = {
            "user_id": user_id,
            "role": role,
            "content": content,
            "tool_calls": tool_calls,
            "tool_call_id": tool_call_id,
            "tool_name": None,  # Will be set when processing tool calls
        }
        return cls(**message_data)


class Resource(SQLModel, table=True):
    __tablename__ = "resources"  # type: ignore
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(max_length=100)
    type: Optional[enums.ResourceType] = Field(max_length=30)
    authors: Optional[List[str]] = Field(sa_column=Column(ARRAY(String(50))))
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )

    """ RELATIONSHIPS """
    resource_classes: Optional[List["ClassResource"]] = Relationship(
        back_populates="resource_", cascade_delete=True
    )
    # resource_sections: Optional[List["Section"]] = Relationship(
    #     back_populates="resource_", cascade_delete=True
    # )
    resource_chunks: Optional[List["Chunk"]] = Relationship(
        back_populates="resource_", cascade_delete=True
    )


class ClassResource(SQLModel, table=True):
    __tablename__ = "classes_resources"  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    class_id: int = Field(foreign_key="classes.id", index=True, ondelete="CASCADE")
    resource_id: int = Field(foreign_key="resources.id", index=True, ondelete="CASCADE")

    """ RELATIONSHIPS """
    class_: Class = Relationship(back_populates="class_resources")
    resource_: Resource = Relationship(back_populates="resource_classes")


class Chunk(SQLModel, table=True):
    __tablename__ = "chunks"  # type: ignore
    __table_args__ = (
        Index(
            "chunk_embedding_idx",  # index name
            "embedding",  # column name
            postgresql_using="hnsw",
            postgresql_with={"m": 16, "ef_construction": 64},
            postgresql_ops={"embedding": "vector_cosine_ops"},
        ),
    )
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    resource_id: int = Field(foreign_key="resources.id", index=True, ondelete="CASCADE")
    # section_id: Optional[int] = Field(
    #     foreign_key="sections.id", index=True, ondelete="CASCADE", default=None
    # )
    content: str
    page_number: Optional[int] = Field(default=None)
    # TODO: Define the different types of chunks in an enum
    chunk_type: Optional[enums.ChunkType] = Field(max_length=30, default=None)
    """
    XXX: FILL IN THE EMBEDDING LENGTH FOR YOUR EMBEDDINGS
    - Default is set to 1024 (for bge-large vectors)
    - Replace with 1536 for text-embedding-3-small if using OpenAI's embedder
    """
    embedding: Any = Field(sa_column=Column(Vector(1024)))
    top_level_section_index: Optional[str] = Field(max_length=10, default=None)
    top_level_section_title: Optional[str] = Field(max_length=100, default=None)
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )

    """ RELATIONSHIPS """
    resource_: Optional["Resource"] = Relationship(back_populates="resource_chunks")
    # section_: Optional["Section"] = Relationship(back_populates="section_chunks")


# class Section(SQLModel, table=True):
#     __tablename__ = "sections"

#     """ FIELDS """
#     id: Optional[int] = Field(default=None, primary_key=True)
#     resource_id: int = Field(foreign_key="resources.id", index=True, ondelete="CASCADE")
#     parent_section_id: Optional[int] = Field(
#         default=None, foreign_key="sections.id", nullable=True
#     )
#     section_index: Optional[str] = Field(max_length=20, default=None)
#     section_title: Optional[str] = Field(max_length=100, default=None)
#     section_type: Optional[str] = Field(max_length=15, default=None)
#     section_order: int
#     page_range: Optional[List[int]] = Field(sa_column=Column(ARRAY(Integer)))
#     summary: Optional[str] = Field(default=None)
#     created_at: Optional[datetime] = Field(
#         default_factory=lambda: datetime.now(timezone.utc),
#         sa_type=DateTime(timezone=True),  # type: ignore
#         sa_column_kwargs={"server_default": sa.func.now()},
#         nullable=False,
#     )

#     """ RELATIONSHIPS """
#     resource_: Resource = Relationship(back_populates="resource_sections")
#     parent: Optional["Section"] = Relationship(
#         back_populates="children",
#         sa_relationship_kwargs={
#             "remote_side": "[Section.id]"  # Quote wrapped to handle forward references
#         },
#     )

#     # Only part I'm not too sure about
#     children: Optional[List["Section"]] = Relationship(
#         back_populates="parent",
#         cascade_delete=True,
#         sa_relationship_kwargs={
#             "single_parent": True,  # This ensures a child can only have one parent
#         },
#     )
#     section_chunks: Optional[List["Chunk"]] = Relationship(
#         back_populates="section_", cascade_delete=True
#     )
